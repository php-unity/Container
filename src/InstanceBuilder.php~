<?php

namespace Unity\IoC;

use Unity\Helpers\Str;
use Unity\IoC\Exceptions\NonInjectableClassException;

class InstanceBuilder
{
    /**
     * @var bool $hasDependency Tells if was found at least
     * one required dependency for the instantiating class
     */
    protected $hasDependency;

    /**
     * @var bool $innerInstance Tells if is an
     * instance generated on this class (true), or outside (false)
     *
     * This is an helper property that tell to this class if
     * the current instance was generated by this class as
     * result of a recursive call to the resolve() method or
     * if was generated outside (by the Container class).
     *
     * If it's an inner generated instance of InstanceBuilder
     * resulting from a recursive call to the resolve() method
     * that means that the top most InstanceBuilder is waiting
     * for some dependency(ies) to be resolved by this instance,
     * so, we cannot let the resolve() method of a inner instance
     * throw a NonInjectableClassException.
     */
    protected $innerInstance;

    /**
     * @var InstanceBuilder The current and top most
     * instance, used as Singleton access
     */
    protected static $instance;

    private function __construct($innerInstance = false)
    {
        $this->innerInstance = $innerInstance;
    }

    private function __clone(){}

    /**
     * Build a class, instantiate
     * and return it for the Container
     *
     * @param $class
     * @return object
     */
    static function build($class)
    {
        if(is_null(static::$instance))
            static::$instance = new static;

        return static::$instance->resolve($class);
    }

    /**
     * Start the building of the instantiating
     *
     * @param $class
     * @return object
     * @throws NonInjectableClassException If the container is
     * asking for a class that has'nt an @Injectable annotation
     */
    protected function resolve($class)
    {
        $refClass = $this->getReflectionClass($class);

        if($this->hasDependencies()) {

            if(!$this->innerInstance && !$this->isInjectable($refClass))
                throw new NonInjectableClassException("Trying to get a non injectable class. Check if @Injectable annotation is set on ${class} class annotations");

            return $refClass->newInstanceArgs($this->getDependencies($refClass));
        }
        else
            return $refClass->newInstanceWithoutConstructor();
    }

    /**
     * Check if the instantiating class is marked
     * as an @Injectable class
     *
     * @param \ReflectionClass $refClass
     * @return bool
     */
    protected function isInjectable(\ReflectionClass $refClass)
    {
        $annotations = $this->getAnnotations($refClass);

        return $this->hasInjectableAnnotation($annotations);
    }

    /**
     * Check if the instantiating class
     * annotation contains the "/* @Injectable"
     * string
     *
     * @param $annotations
     * @return bool
     */
    protected function hasInjectableAnnotation($annotations)
    {
        return Str::contains('* @Injectable', $annotations);
    }

    /**
     * Get the instantiating class annotations
     *
     * This string is used by the hasInjectableAnnotation()
     * method to check if the instantiating class
     * is marked as an @Injectable class
     *
     * @param \ReflectionClass $refClass
     * @return string
     */
    protected function getAnnotations(\ReflectionClass $refClass)
    {
        return $refClass->getDocComment();
    }

    /**
     * Returns an array with all necessary
     * dependencies to build the instantiating
     * class
     *
     * @param \ReflectionClass $refClass
     * @return array
     */
    protected function getDependencies(\ReflectionClass $refClass)
    {
        return array_map(function (\ReflectionType $type){

            if(class_exists($type)) {

                if(!$this->hasDependency)
                        $this->hasDependency = true;

                $ib = new InstanceBuilder(true);

                return $ib->resolve($type);
            }

            return null;
        }, $this->getParametersType($refClass));
    }

    /**
     * @return bool Return true if was founded at least one
     * required dependency for the instantiating class
     */
    protected function hasDependencies()
    {
        return $this->hasDependency;
    }

    /**
     * Returns an array with all respective
     * parameters types in the constructor
     * of the instantiating class
     *
     * @param \ReflectionClass $refClass
     * @return array
     */
    protected function getParametersType(\ReflectionClass $refClass)
    {
        $params = [];

        if($this->hasParameters($refClass)) {
            $parameters = $refClass
                ->getConstructor()
                ->getParameters();

            foreach ($parameters as $param)
                $params[] = $param->getType();
        }

        return $params;
    }

    /**
     * Check if the instantiating class has
     * parameters in the constructor
     *
     * @param \ReflectionClass $refClass
     * @return bool
     */
    protected function hasParameters(\ReflectionClass $refClass)
    {
        $constructor = $refClass->getConstructor();

        return $constructor && ($constructor->getNumberOfParameters() > 0);
    }

    /**
     * Returns a \ReflectionClass instance based
     * on the provided $class parameter,
     *
     * @param string|null $class
     * @return \ReflectionClass
     */
    protected function getReflectionClass($class = null)
    {
        return new \ReflectionClass($class);
    }
}